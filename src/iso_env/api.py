"""
Unit test file.
"""

import os
import shutil
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path


@dataclass
class Requirements:
    content: str
    python_version: str | None = None

    def __post_init__(self):
        self.content = self.content.strip()

    def __repr__(self):
        return self.content


@dataclass
class PyProjectToml:
    content: str

    def __post_init__(self):
        self.content = self.content.strip()

    def __repr__(self):
        return self.content


@dataclass
class IsoEnvArgs:
    venv_path: Path
    build_info: Requirements | PyProjectToml


def _to_requirements(build_info: Requirements) -> PyProjectToml:
    req_lines = build_info.content.split("\n")
    req_lines = [line.strip() for line in req_lines if line.strip()]
    headers = ["# This file is generated by iso_env.", "# Do not edit this file."]
    headers.append("[project]")
    headers.append('name = "project"')
    if build_info.python_version:
        headers.append(f'requires-python = "{build_info.python_version}"')
    headers.append('version = "0.1.0"')
    if req_lines:
        headers.append("dependencies = [")
        for line in build_info.content.split("\n"):
            headers.append(f'  "{line}",')
        headers.append("]")
    return PyProjectToml("\n".join(headers))


def _to_pyproject_toml(build_info: Requirements | PyProjectToml) -> PyProjectToml:
    if isinstance(build_info, Requirements):
        return _to_requirements(build_info)
    return build_info


# def install(path: Path, requirements_text: str) -> None:
def install(args: IsoEnvArgs, verbose: bool) -> None:
    """Uses isolated_environment to install aider."""
    # env: dict = dict(os.environ)
    try:
        path = args.venv_path
        if installed(args, verbose=verbose):
            if verbose:
                print(f"{path} is already installed.")
            return
        py_project_toml = _to_pyproject_toml(args.build_info)
        # Print installing message
        # Install aider using isolated_environment
        path.mkdir(exist_ok=True, parents=True)

        cmd_list = ["uv", "venv"]
        # cmd_str =
        if verbose:
            cmd_str = subprocess.list2cmdline(cmd_list)
            print(f"Installing in {path} using command: {cmd_str}")
        subprocess.run(
            cmd_list,
            cwd=str(path),
            check=True,
            capture_output=True,
            text=True,
            shell=True,
        )
        py_project_toml_path = path / "pyproject.toml"
        py_project_toml_path.write_text(str(py_project_toml), encoding="utf-8")
        if verbose:
            print(
                f"Installed pyproject.toml in {py_project_toml_path}:\n{py_project_toml}"
            )
        (path / "installed").touch()
    except KeyboardInterrupt:
        pass


def purge(venv_path: Path) -> int:
    print("Purging...")
    if not venv_path.exists():
        print("venv_path does not exist.")
        return 0
    try:
        shutil.rmtree(venv_path)
        print("purged successfully.")
        return 0
    except Exception as e:
        print(f"Error purging aider: {e}")
        return 1


def _santize(context: str) -> str:
    new_lines: list[str] = []
    for line in context.split("\n"):
        line = line.strip()
        if line:
            new_lines.append(line)
    return "\n".join(new_lines)


# def installed(venv_path: Path, requirements_text: str) -> bool:
def installed(args: IsoEnvArgs, verbose: bool) -> bool:
    if verbose:
        print(f"Checking if {args.venv_path} is installed.")
    venv_path = args.venv_path
    if not venv_path.exists():
        if verbose:
            print(f"{venv_path} does not exist.")
        return False
    pyproject_toml_path = venv_path / "pyproject.toml"
    if not pyproject_toml_path.exists():
        if verbose:
            print(f"{pyproject_toml_path} does not exist.")
        return False
    pyproject_toml = _to_pyproject_toml(args.build_info)
    if verbose:
        print(f"Checking {pyproject_toml_path} and {pyproject_toml}")
    if _santize(pyproject_toml_path.read_text()) != _santize(str(pyproject_toml)):
        if verbose:
            print(f"{pyproject_toml_path} is different.")
        return False
    out = (venv_path / "installed").exists()
    if verbose:
        print(f"Installed: {out}")
    return out


def open_proc(
    args: IsoEnvArgs, cmd_list: list[str] | str, verbose=False, **process_args
) -> subprocess.Popen:
    """Runs the command using the isolated environment."""
    if not installed(args, verbose=verbose):
        purge(args.venv_path)
        install(args, verbose=verbose)

    python_exe = sys.executable
    preamble = [
        python_exe,
        "-m",
        "uv",
        "run",
        "--isolated",
        "--project",
        str(args.venv_path),
    ]
    if isinstance(cmd_list, list):
        full_cmd = preamble + cmd_list
        full_cmd_str = subprocess.list2cmdline(full_cmd)
    else:
        full_cmd_str = subprocess.list2cmdline(preamble) + " " + cmd_list
    env = dict(os.environ)
    # cp = subprocess.run(full_cmd_str, env=env, shell=True, **process_args)
    # return cp
    capture_output = process_args.pop("capture_output", False)
    shell = process_args.pop("shell", True)
    if verbose:
        full_path = Path(".").resolve()
        print(f"Running in {full_path}: {full_cmd_str}")
    if not capture_output:
        proc = subprocess.Popen(full_cmd_str, env=env, shell=shell, **process_args)
        return proc

    proc = subprocess.Popen(
        full_cmd_str,
        env=env,
        shell=shell,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        **process_args,
    )
    return proc


def run(
    args: IsoEnvArgs, cmd_list: list[str] | str, verbose=False, **process_args
) -> subprocess.CompletedProcess:
    """Runs the command using the isolated environment."""
    check = process_args.pop("check", False)
    proc = open_proc(args, cmd_list, verbose=verbose, **process_args)
    proc.wait()
    cp: subprocess.CompletedProcess = subprocess.CompletedProcess(
        args=proc.args,
        returncode=proc.returncode,
        stdout=proc.stdout,
        stderr=proc.stderr,
    )
    if check and cp.returncode != 0:
        raise subprocess.CalledProcessError(
            cp.returncode, cp.args, cp.stdout, cp.stderr
        )
    return cp


class IsoEnv:
    def __init__(self, args: IsoEnvArgs) -> None:
        self.args = args

    def run(
        self, cmd_list: list[str] | str, **process_args
    ) -> subprocess.CompletedProcess:
        return run(self.args, cmd_list, **process_args)

    def open_proc(self, cmd_list: list[str] | str, **process_args) -> subprocess.Popen:
        return open_proc(self.args, cmd_list, **process_args)
